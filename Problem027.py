'''
#-------------problem-------------
오일러는 다음과 같은 멋진 2차식을 제시했습니다.
n2 + n + 41
이 식의 n에다 0부터 39 사이의 숫자를 넣으면, 그 결과는 모두 소수가 됩니다.
하지만 n = 40일 때의 값 402 + 40 + 41 은 40×(40 + 1) + 41 이므로 41로 나누어지고, n = 41일 때 역시 412 + 41 + 41 이므로 소수가 아닙니다.
컴퓨터의 발전에 힘입어 n2 − 79n + 1601 이라는 엄청난 2차식이 발견되었는데, 이것은 n이 0에서 79 사이일 때 모두 80개의 소수를 만들어냅니다. 
이 식의 계수의 곱은 -79 × 1601 = -126479가 됩니다.
아래와 같은 모양의 2차식이 있다고 가정했을 때,
n2 + an + b   (단 | a | < 1000, | b | < 1000)
0부터 시작하는 연속된 n에 대해 가장 많은 소수를 만들어내는 2차식을 찾아서, 그 계수 a와 b의 곱을 구하세요.
#-------------solution-------------
1. n2 + an + b로 구할 수 있는 최대값 a,b를 구한다.
2. 최대값 a보다 작은 소수로 이루어진 리스트를 만든다.
3. n과 a와 b에 값을 넣어 계산한 결과 b가 소수인지 리스트에서 확인한다. 만약 b가 소수라면 n을 +1한다.
3. 이전 정답과 비교하여 n이 더 크면 정답을 변환한다.
#-------------code-------------
#1.솔루션 1번 최대값 a,b 구하기
n^2 + an + b = n^2 + 79n + 1601  
a = 79 => 2*40 - 1
b = 1601 => 40^2 + 1

prime_list = Q7()
print("소수리스트생성완료")
answer = 0
save_a_b = 0
for a in range(-999,1000) :
    for b in range(-999,1000) :
        n = 0
        value = 2
        while value in prime_list :
            value = n ** 2 + a * n + b
            #print(value)
            if value in prime_list :
                n += 1
        if n > answer :
            answer = n
            save_a_b = (a, b , a*b, n)

    print(save_a_b)

#번외 아래도 사용가능하다고 함
def intersection(a,b) :
    return list(set(a)&set(b))

#-------------spending time-------------
# 969..seconds ---
